<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Pixel Notepad ✦ 像素记事板</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%; height: 100%;
      overflow: hidden;
      background: #2b2b2b;
      font-family: 'Press Start 2P', 'Courier New', monospace;
      color: #8bac0f;
      -webkit-user-select: none;
      user-select: none;
    }

    .app {
      display: flex;
      flex-direction: column;
      height: 100vh;
      width: 100%;
    }

    /* ========== 顶部工具栏 - 游戏机外壳风格 ========== */
    .toolbar {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 10px 14px;
      background: #3a3a3a;
      border-bottom: 3px solid #1a1a1a;
      flex-shrink: 0;
      flex-wrap: wrap;
      z-index: 10;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.05);
    }

    .toolbar-group {
      display: flex;
      align-items: center;
      gap: 5px;
      padding: 0 8px;
      border-right: 2px solid #2b2b2b;
    }
    .toolbar-group:last-child { border-right: none; }

    .toolbar-label {
      font-size: 7px;
      color: #6a6a6a;
      letter-spacing: 1px;
      text-transform: uppercase;
      margin-right: 4px;
      white-space: nowrap;
    }

    .tool-btn {
      width: 36px; height: 36px;
      border: 2px solid #1a1a1a;
      border-radius: 4px;
      background: #4a4a4a;
      color: #8bac0f;
      font-size: 14px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.1s;
      position: relative;
      box-shadow: inset 0 -2px 0 #333, inset 0 1px 0 #555;
      font-family: 'Press Start 2P', monospace;
    }
    .tool-btn:hover {
      background: #555;
      color: #9bbc0f;
      box-shadow: inset 0 -1px 0 #444, inset 0 1px 0 #666;
    }
    .tool-btn:active {
      background: #3a3a3a;
      box-shadow: inset 0 2px 0 #2a2a2a;
      transform: translateY(1px);
    }
    .tool-btn.active {
      background: #306230;
      color: #9bbc0f;
      border-color: #0f380f;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.4), 0 0 8px rgba(139,172,15,0.2);
    }

    .tool-btn-wide {
      width: auto;
      padding: 0 10px;
      font-size: 8px;
      gap: 4px;
      white-space: nowrap;
    }

    /* Game Boy 4色调色板 */
    .color-swatch {
      width: 26px; height: 26px;
      border: 2px solid #1a1a1a;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.1s;
      flex-shrink: 0;
      box-shadow: inset 0 -1px 0 rgba(0,0,0,0.3);
    }
    .color-swatch:hover { transform: scale(1.1); }
    .color-swatch.active {
      border-color: #9bbc0f;
      box-shadow: 0 0 8px rgba(139,172,15,0.5), inset 0 -1px 0 rgba(0,0,0,0.3);
      transform: scale(1.08);
    }

    /* 滑块 - 游戏机风格 */
    .size-slider {
      -webkit-appearance: none;
      appearance: none;
      width: 80px;
      height: 6px;
      background: #1a1a1a;
      border-radius: 3px;
      outline: none;
      cursor: pointer;
      border: 1px solid #0f0f0f;
    }
    .size-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px; height: 18px;
      border-radius: 2px;
      background: #8bac0f;
      border: 2px solid #306230;
      cursor: pointer;
      box-shadow: 0 0 4px rgba(139,172,15,0.3);
    }
    .size-value {
      font-size: 8px;
      color: #6a6a6a;
      min-width: 20px;
      text-align: center;
      font-family: 'Press Start 2P', monospace;
    }

    /* 像素块大小输入 */
    .pixel-size-input {
      width: 42px;
      padding: 4px 4px;
      background: #1a1a1a;
      border: 2px solid #0f380f;
      border-radius: 3px;
      color: #8bac0f;
      font-size: 8px;
      text-align: center;
      outline: none;
      font-family: 'Press Start 2P', monospace;
    }
    .pixel-size-input:focus {
      border-color: #9bbc0f;
      box-shadow: 0 0 6px rgba(139,172,15,0.3);
    }

    /* ========== 画布区域 - Game Boy 屏幕 ========== */
    .canvas-area {
      flex: 1;
      position: relative;
      overflow: hidden;
      margin: 12px;
      border-radius: 8px;
      border: 4px solid #1a1a1a;
      box-shadow:
        inset 0 0 30px rgba(0,0,0,0.3),
        0 0 0 2px #4a4a4a,
        0 4px 12px rgba(0,0,0,0.4);
      background: #9bbc0f;
    }

    .canvas-wrapper {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
    }

    canvas {
      display: block;
      cursor: crosshair;
      touch-action: none;
    }

    /* 像素化叠加层 */
    #pixelCanvas {
      position: absolute;
      top: 0; left: 0;
      pointer-events: none;
      image-rendering: pixelated;
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
      opacity: 0;
      transition: opacity 0.3s;
    }
    #pixelCanvas.visible {
      opacity: 1;
      pointer-events: auto;
      cursor: crosshair;
    }

    /* ========== 底部状态栏 ========== */
    .statusbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 14px;
      background: #3a3a3a;
      border-top: 3px solid #1a1a1a;
      font-size: 7px;
      color: #5a5a5a;
      flex-shrink: 0;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.03);
    }
    .statusbar-hint { letter-spacing: 0.5px; }

    /* 品牌标识 */
    .brand-tag {
      font-size: 8px;
      color: #555;
      letter-spacing: 2px;
      text-align: center;
      padding: 2px 0;
    }

    /* ========== 提示消息 - 像素风弹窗 ========== */
    .toast {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%) translateY(20px);
      background: #0f380f;
      color: #9bbc0f;
      padding: 10px 20px;
      border-radius: 0;
      border: 3px solid #306230;
      font-size: 8px;
      font-family: 'Press Start 2P', monospace;
      box-shadow: 4px 4px 0 #0a0a0a;
      z-index: 100;
      opacity: 0;
      pointer-events: none;
      transition: all 0.2s ease;
      white-space: nowrap;
    }
    .toast.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    /* ========== 橡皮擦光标 ========== */
    .eraser-cursor { cursor: none; }
    .eraser-ring {
      position: fixed;
      pointer-events: none;
      border: 2px solid rgba(15,56,15,0.6);
      border-radius: 0;
      z-index: 20;
      display: none;
    }

    /* 屏幕扫描线效果 */
    .scanlines {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 5;
      background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        rgba(0, 0, 0, 0.03) 2px,
        rgba(0, 0, 0, 0.03) 4px
      );
    }

    /* ========== 远程玩家光标 ========== */
    .remote-cursor {
      position: absolute;
      pointer-events: none;
      z-index: 15;
      transition: left 0.08s linear, top 0.08s linear;
    }
    .remote-cursor-dot {
      width: 8px; height: 8px;
      border: 2px solid #0f380f;
      border-radius: 0;
      background: #306230;
      box-shadow: 0 0 6px rgba(48,98,48,0.6);
    }
    .remote-cursor-label {
      position: absolute;
      top: 12px; left: 4px;
      font-size: 6px;
      font-family: 'Press Start 2P', monospace;
      color: #306230;
      background: rgba(15,56,15,0.7);
      padding: 2px 4px;
      border: 1px solid #306230;
      white-space: nowrap;
    }

    /* ========== 在线人数指示器 ========== */
    .online-indicator {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 7px;
      color: #5a5a5a;
      font-family: 'Press Start 2P', monospace;
    }
    .online-dot {
      width: 6px; height: 6px;
      border-radius: 0;
      background: #306230;
      box-shadow: 0 0 4px rgba(48,98,48,0.5);
      animation: blink-dot 2s ease-in-out infinite;
    }
    @keyframes blink-dot {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }

    /* 自动保存指示 */
    .autosave-indicator {
      font-size: 6px;
      color: #4a4a4a;
      font-family: 'Press Start 2P', monospace;
      transition: color 0.3s;
    }
    .autosave-indicator.saving {
      color: #8bac0f;
    }

    /* Board ID 显示 */
    .board-id-tag {
      font-size: 6px;
      color: #8bac0f;
      font-family: 'Press Start 2P', monospace;
      cursor: pointer;
      padding: 2px 6px;
      border: 1px solid #306230;
      background: rgba(15,56,15,0.4);
      transition: all 0.2s;
      white-space: nowrap;
      max-width: 160px;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .board-id-tag:hover {
      background: rgba(48,98,48,0.5);
      color: #9bbc0f;
    }

    /* ========== 导出弹窗 ========== */
    .export-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.7);
      z-index: 200;
      display: none;
      align-items: center;
      justify-content: center;
    }
    .export-overlay.open { display: flex; }

    .export-panel {
      background: #3a3a3a;
      border: 4px solid #1a1a1a;
      box-shadow: 8px 8px 0 #0a0a0a, 0 0 0 2px #4a4a4a;
      padding: 20px;
      min-width: 320px;
      max-width: 90vw;
      max-height: 85vh;
      overflow-y: auto;
    }

    .export-title {
      font-size: 10px;
      color: #9bbc0f;
      text-align: center;
      margin-bottom: 16px;
      letter-spacing: 2px;
    }

    .export-sizes {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
      margin-bottom: 16px;
    }

    .export-size-btn {
      padding: 10px 6px;
      background: #4a4a4a;
      border: 2px solid #1a1a1a;
      border-radius: 4px;
      color: #8bac0f;
      font-family: 'Press Start 2P', monospace;
      font-size: 8px;
      cursor: pointer;
      text-align: center;
      transition: all 0.1s;
      box-shadow: inset 0 -2px 0 #333, inset 0 1px 0 #555;
    }
    .export-size-btn:hover {
      background: #555;
      color: #9bbc0f;
    }
    .export-size-btn:active {
      background: #3a3a3a;
      box-shadow: inset 0 2px 0 #2a2a2a;
      transform: translateY(1px);
    }
    .export-size-btn.selected {
      background: #306230;
      color: #9bbc0f;
      border-color: #8bac0f;
      box-shadow: 0 0 8px rgba(139,172,15,0.3);
    }

    .export-preview-area {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      margin-bottom: 16px;
    }

    .export-preview-label {
      font-size: 7px;
      color: #6a6a6a;
      letter-spacing: 1px;
    }

    .export-preview-wrap {
      background: #1a1a1a;
      border: 2px solid #0f380f;
      padding: 8px;
      display: inline-block;
      image-rendering: pixelated;
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
    }

    .export-preview-wrap canvas {
      display: block;
      image-rendering: pixelated;
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
    }

    .export-actions {
      display: flex;
      gap: 8px;
      justify-content: center;
    }

    .export-action-btn {
      padding: 10px 18px;
      background: #306230;
      border: 2px solid #0f380f;
      border-radius: 4px;
      color: #9bbc0f;
      font-family: 'Press Start 2P', monospace;
      font-size: 8px;
      cursor: pointer;
      box-shadow: inset 0 -2px 0 #1a3a1a, inset 0 1px 0 #4a8a4a;
      transition: all 0.1s;
    }
    .export-action-btn:hover {
      background: #3a7a3a;
      color: #fff;
    }
    .export-action-btn:active {
      transform: translateY(1px);
      box-shadow: inset 0 2px 0 #1a3a1a;
    }
    .export-action-btn.cancel {
      background: #4a4a4a;
      border-color: #1a1a1a;
      color: #8bac0f;
      box-shadow: inset 0 -2px 0 #333, inset 0 1px 0 #555;
    }
    .export-action-btn.cancel:hover {
      background: #555;
    }

    /* 自定义尺寸输入 */
    .export-custom {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      margin-bottom: 16px;
    }
    .export-custom-input {
      width: 50px;
      padding: 6px 4px;
      background: #1a1a1a;
      border: 2px solid #0f380f;
      border-radius: 3px;
      color: #8bac0f;
      font-size: 8px;
      text-align: center;
      outline: none;
      font-family: 'Press Start 2P', monospace;
    }
    .export-custom-input:focus {
      border-color: #9bbc0f;
      box-shadow: 0 0 6px rgba(139,172,15,0.3);
    }
    .export-custom-x {
      font-size: 8px;
      color: #6a6a6a;
    }

    /* ========== 框选矩形 ========== */
    .select-rect {
      position: absolute;
      border: 2px dashed #0f380f;
      background: rgba(15,56,15,0.12);
      pointer-events: none;
      z-index: 12;
      box-shadow: 0 0 6px rgba(15,56,15,0.3);
    }

    /* ========== 猜谜标签（画布上的 ??? 标记） ========== */
    .riddle-tag {
      position: absolute;
      z-index: 14;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: 'Press Start 2P', monospace;
      font-size: 9px;
      color: #0f380f;
      background: transparent;
      border: 2px dashed #0f380f;
      box-shadow: none;
      transition: all 0.15s;
      text-align: center;
      line-height: 1.4;
      padding: 2px 4px;
      min-width: 40px;
      min-height: 24px;
      overflow: visible;
    }
    .riddle-tag:hover {
      border-color: #9bbc0f;
      box-shadow: 0 0 10px rgba(139,172,15,0.4);
      transform: scale(1.02);
    }
    .riddle-tag.solved {
      background: transparent;
      border: 2px solid rgba(255,255,255,0.85);
      color: #fff;
      box-shadow: 0 0 12px rgba(255,255,255,0.5), inset 0 0 8px rgba(255,255,255,0.1);
    }
    .riddle-tag.solved:hover {
      box-shadow: 0 0 18px rgba(255,255,255,0.7);
    }
    /* ??? 文字标签定位在选区底部外侧 */
    .riddle-tag-label {
      position: absolute;
      bottom: -18px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 8px;
      white-space: nowrap;
      padding: 1px 6px;
      background: rgba(15,56,15,0.8);
      border: 1px solid #306230;
      border-radius: 2px;
      color: #9bbc0f;
      pointer-events: none;
    }
    .riddle-tag.solved .riddle-tag-label {
      background: rgba(255,255,255,0.9);
      border-color: rgba(255,255,255,0.6);
      color: #0f380f;
    }

    /* ========== 猜谜弹窗（通用） ========== */
    .riddle-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.7);
      z-index: 300;
      display: none;
      align-items: center;
      justify-content: center;
    }
    .riddle-overlay.open { display: flex; }

    .riddle-panel {
      background: #3a3a3a;
      border: 4px solid #1a1a1a;
      box-shadow: 8px 8px 0 #0a0a0a, 0 0 0 2px #4a4a4a;
      padding: 36px;
      min-width: 420px;
      max-width: 92vw;
      text-align: center;
    }

    .riddle-panel-title {
      font-size: 15px;
      color: #9bbc0f;
      margin-bottom: 22px;
      letter-spacing: 2px;
    }

    .riddle-panel-desc {
      font-size: 11px;
      color: #6a6a6a;
      margin-bottom: 18px;
      line-height: 1.8;
    }

    .riddle-input {
      width: 100%;
      padding: 16px 18px;
      background: #1a1a1a;
      border: 3px solid #0f380f;
      border-radius: 4px;
      color: #8bac0f;
      font-family: 'Press Start 2P', monospace;
      font-size: 14px;
      text-align: center;
      outline: none;
      margin-bottom: 20px;
    }
    .riddle-input:focus {
      border-color: #9bbc0f;
      box-shadow: 0 0 10px rgba(139,172,15,0.4);
    }

    .riddle-btns {
      display: flex;
      gap: 12px;
      justify-content: center;
    }

    .riddle-btn {
      padding: 14px 24px;
      background: #306230;
      border: 2px solid #0f380f;
      border-radius: 4px;
      color: #9bbc0f;
      font-family: 'Press Start 2P', monospace;
      font-size: 11px;
      cursor: pointer;
      box-shadow: inset 0 -2px 0 #1a3a1a, inset 0 1px 0 #4a8a4a;
      transition: all 0.1s;
    }
    .riddle-btn:hover {
      background: #3a7a3a;
      color: #fff;
    }
    .riddle-btn:active {
      transform: translateY(1px);
      box-shadow: inset 0 2px 0 #1a3a1a;
    }
    .riddle-btn.cancel {
      background: #4a4a4a;
      border-color: #1a1a1a;
      color: #8bac0f;
      box-shadow: inset 0 -2px 0 #333, inset 0 1px 0 #555;
    }

    /* ========== 像素风确认弹窗（替代 confirm） ========== */
    .pixel-confirm-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.75);
      z-index: 500;
      display: flex;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.15s ease;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    .pixel-confirm-panel {
      background: #3a3a3a;
      border: 4px solid #1a1a1a;
      box-shadow: 8px 8px 0 #0a0a0a, 0 0 0 2px #4a4a4a;
      padding: 30px 36px;
      min-width: 340px;
      max-width: 88vw;
      text-align: center;
    }
    .pixel-confirm-msg {
      font-size: 12px;
      color: #9bbc0f;
      margin-bottom: 24px;
      letter-spacing: 1px;
      line-height: 1.6;
    }
    .pixel-confirm-btns {
      display: flex;
      gap: 12px;
      justify-content: center;
    }
    .pixel-confirm-btn {
      padding: 12px 22px;
      border: 2px solid #0f380f;
      border-radius: 4px;
      font-family: 'Press Start 2P', monospace;
      font-size: 10px;
      cursor: pointer;
      transition: all 0.1s;
    }
    .pixel-confirm-btn.yes {
      background: #8b2020;
      color: #ffaaaa;
      border-color: #5a1010;
      box-shadow: inset 0 -2px 0 #601515, inset 0 1px 0 #b03030;
    }
    .pixel-confirm-btn.yes:hover {
      background: #a03030;
      color: #fff;
    }
    .pixel-confirm-btn.no {
      background: #4a4a4a;
      color: #8bac0f;
      border-color: #1a1a1a;
      box-shadow: inset 0 -2px 0 #333, inset 0 1px 0 #555;
    }
    .pixel-confirm-btn.no:hover {
      background: #555;
      color: #9bbc0f;
    }

    /* 猜中弹窗 */
    .riddle-success-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.8);
      z-index: 400;
      display: none;
      align-items: center;
      justify-content: center;
    }
    .riddle-success-overlay.open { display: flex; }

    .riddle-success-panel {
      background: #0f380f;
      border: 4px solid #306230;
      box-shadow: 0 0 40px rgba(139,172,15,0.4), 8px 8px 0 #0a0a0a;
      padding: 30px 40px;
      text-align: center;
      animation: successPop 0.4s ease;
    }
    @keyframes successPop {
      0% { transform: scale(0.5); opacity: 0; }
      70% { transform: scale(1.08); }
      100% { transform: scale(1); opacity: 1; }
    }
    .riddle-success-title {
      font-size: 12px;
      color: #9bbc0f;
      margin-bottom: 8px;
      letter-spacing: 2px;
    }
    .riddle-success-word {
      font-size: 14px;
      color: #8bac0f;
      margin-bottom: 18px;
    }
    .riddle-success-btn {
      padding: 10px 24px;
      background: #306230;
      border: 2px solid #8bac0f;
      border-radius: 4px;
      color: #9bbc0f;
      font-family: 'Press Start 2P', monospace;
      font-size: 9px;
      cursor: pointer;
      box-shadow: 0 0 12px rgba(139,172,15,0.3);
    }
    .riddle-success-btn:hover {
      background: #3a7a3a;
      color: #fff;
    }

    /* 响应式 */
    @media (max-width: 680px) {
      .toolbar { padding: 6px 8px; gap: 4px; }
      .toolbar-label { display: none; }
      .tool-btn { width: 30px; height: 30px; font-size: 12px; }
      .size-slider { width: 50px; }
      .canvas-area { margin: 6px; }
      .board-id-tag { max-width: 80px; font-size: 5px; }
      .export-panel { min-width: unset; padding: 14px; }
      .export-sizes { grid-template-columns: repeat(2, 1fr); }
      .riddle-panel { min-width: unset; padding: 16px; }
    }
  </style>
</head>
<body>

<div class="app">
  <!-- 工具栏 -->
  <div class="toolbar">
    <div class="toolbar-group">
      <span class="toolbar-label">TOOL</span>
      <button class="tool-btn active" id="btnPen" title="画笔">✎</button>
      <button class="tool-btn" id="btnEraser" title="橡皮擦">◻</button>
      <button class="tool-btn tool-btn-wide" id="btnSelect" title="框选（你画我猜）" style="background:#8bac0f;color:#1a1a1a;border-color:#306230;font-size:9px;padding:0 12px;">⬚ GUESS</button>
    </div>

    <div class="toolbar-group">
      <span class="toolbar-label">INK</span>
      <div class="color-swatch active" style="background:#0f380f" data-color="#0f380f" title="最深"></div>
      <div class="color-swatch" style="background:#306230" data-color="#306230" title="深"></div>
      <div class="color-swatch" style="background:#8bac0f" data-color="#8bac0f" title="浅"></div>
      <div class="color-swatch" style="background:#9bbc0f" data-color="#9bbc0f" title="最浅（背景色）"></div>
    </div>

    <div class="toolbar-group">
      <span class="toolbar-label">SIZE</span>
      <input type="range" class="size-slider" id="sizeSlider" min="1" max="20" value="3">
      <span class="size-value" id="sizeValue">3</span>
    </div>

    <div class="toolbar-group">
      <span class="toolbar-label">PIXEL</span>
      <input type="number" class="pixel-size-input" id="pixelSizeInput" value="6" min="2" max="24" title="像素块大小">
      <button class="tool-btn tool-btn-wide" id="btnPixelate" title="4色像素化">▦ 4C</button>
      <button class="tool-btn tool-btn-wide" id="btnPixelate2bit" title="2色像素化（纯二值）">▦ 2C</button>
      <button class="tool-btn tool-btn-wide" id="btnOriginal" title="恢复原始画作" style="display:none;">▤ ORI</button>
    </div>

    <div class="toolbar-group">
      <span class="toolbar-label">ACT</span>
      <button class="tool-btn" id="btnUndo" title="撤销">↶</button>
      <button class="tool-btn" id="btnRedo" title="重做">↷</button>
      <button class="tool-btn" id="btnClear" title="清空画布">✕</button>
      <button class="tool-btn" id="btnSave" title="保存为图片">⇩</button>
      <button class="tool-btn tool-btn-wide" id="btnExportPixel" title="导出2bit像素画">▦ EXP</button>
    </div>
  </div>

  <!-- 画布 -->
  <div class="canvas-area" id="canvasArea">
    <div class="canvas-wrapper">
      <canvas id="drawCanvas"></canvas>
      <canvas id="pixelCanvas"></canvas>
    </div>
    <div class="scanlines"></div>
  </div>

  <!-- 状态栏 -->
  <div class="statusbar">
    <span class="statusbar-hint">DRAW · PIXELIZE · SAVE</span>
    <div class="online-indicator">
      <div class="online-dot"></div>
      <span id="onlineCount">1 ONLINE</span>
    </div>
    <span class="board-id-tag" id="boardIdTag" title="点击复制分享链接">BOARD: ---</span>
    <span class="autosave-indicator" id="autosaveIndicator">AUTO SAVE</span>
    <span class="brand-tag">DOT MATRIX GAME</span>
    <span id="coordsDisplay">—</span>
  </div>
</div>

<!-- 橡皮擦光标 -->
<div class="eraser-ring" id="eraserRing"></div>

<!-- Toast -->
<div class="toast" id="toast"></div>

<!-- 导出像素画弹窗 -->
<div class="export-overlay" id="exportOverlay">
  <div class="export-panel">
    <div class="export-title">▦ EXPORT 2-BIT PIXEL ART ▦</div>
    <div class="export-sizes" id="exportSizes">
      <button class="export-size-btn" data-w="8" data-h="8">8x8</button>
      <button class="export-size-btn selected" data-w="9" data-h="9">9x9</button>
      <button class="export-size-btn" data-w="10" data-h="10">10x10</button>
      <button class="export-size-btn" data-w="16" data-h="16">16x16</button>
      <button class="export-size-btn" data-w="20" data-h="20">20x20</button>
      <button class="export-size-btn" data-w="32" data-h="32">32x32</button>
      <button class="export-size-btn" data-w="48" data-h="48">48x48</button>
      <button class="export-size-btn" data-w="64" data-h="64">64x64</button>
      <button class="export-size-btn" data-w="128" data-h="128">128x128</button>
    </div>
    <div class="export-custom">
      <span class="export-custom-x">CUSTOM:</span>
      <input type="number" class="export-custom-input" id="exportCustomW" value="9" min="2" max="512" placeholder="W">
      <span class="export-custom-x">x</span>
      <input type="number" class="export-custom-input" id="exportCustomH" value="9" min="2" max="512" placeholder="H">
      <button class="export-size-btn" id="exportCustomApply" style="padding:6px 10px;">OK</button>
    </div>
    <div class="export-preview-area">
      <span class="export-preview-label">PREVIEW (<span id="exportPreviewInfo">9x9</span>)</span>
      <div class="export-preview-wrap" id="exportPreviewWrap">
        <canvas id="exportPreviewCanvas"></canvas>
      </div>
    </div>
    <div class="export-actions">
      <button class="export-action-btn" id="exportDownload">⇩ DOWNLOAD PNG</button>
      <button class="export-action-btn cancel" id="exportClose">✕ CLOSE</button>
    </div>
  </div>
</div>

<!-- Firebase SDK (compat 版本，支持直接在 script 标签中使用) -->

<!-- 框选辅助矩形（画布内） -->
<div class="select-rect" id="selectRect" style="display:none;"></div>

<!-- 设置谜题弹窗（出题者输入答案） -->
<div class="riddle-overlay" id="riddleSetOverlay">
  <div class="riddle-panel">
    <div class="riddle-panel-title">▦ 你画我猜 - 设置谜题 ▦</div>
    <p class="riddle-panel-desc">请输入你画的物品名称<br>其他人将看到 ??? 并尝试猜测</p>
    <input type="text" class="riddle-input" id="riddleSetInput" placeholder="输入物品名称..." maxlength="30" autocomplete="off">
    <div class="riddle-btns">
      <button class="riddle-btn" id="riddleSetConfirm">✓ 确认出题</button>
      <button class="riddle-btn cancel" id="riddleSetCancel">✕ 取消</button>
    </div>
  </div>
</div>

<!-- 猜谜弹窗（猜测者输入） -->
<div class="riddle-overlay" id="riddleGuessOverlay">
  <div class="riddle-panel">
    <div class="riddle-panel-title">▦ 你画我猜 - 猜猜看！ ▦</div>
    <p class="riddle-panel-desc">这幅画画的是什么？</p>
    <input type="text" class="riddle-input" id="riddleGuessInput" placeholder="输入你的答案..." maxlength="30" autocomplete="off">
    <p id="riddleGuessHint" style="font-size:11px;color:#ff6060;margin-bottom:14px;display:none;">答案不对，再想想！</p>
    <div class="riddle-btns">
      <button class="riddle-btn" id="riddleGuessConfirm">✓ 提交答案</button>
      <button class="riddle-btn cancel" id="riddleGuessCancel">✕ 关闭</button>
    </div>
  </div>
</div>

<!-- 猜中弹窗 -->
<div class="riddle-success-overlay" id="riddleSuccessOverlay">
  <div class="riddle-success-panel">
    <div class="riddle-success-title">★ 恭喜你猜中了 ★</div>
    <div class="riddle-success-word" id="riddleSuccessWord"></div>
    <button class="riddle-success-btn" id="riddleSuccessClose">OK!</button>
  </div>
</div>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

<script>
  // =============================================
  //  Firebase 初始化
  // =============================================
  const firebaseConfig = {
    apiKey: "AIzaSyCfrXSEmDx2xURYGBvU8l7zhqG4WgKa45U",
    authDomain: "pixelartboard.firebaseapp.com",
    databaseURL: "https://pixelartboard-default-rtdb.firebaseio.com",
    projectId: "pixelartboard",
    storageBucket: "pixelartboard.firebasestorage.app",
    messagingSenderId: "478073889757",
    appId: "1:478073889757:web:b3029c975aa5089d69cc34",
    measurementId: "G-DFMG0RQPYQ"
  };

  firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  // =============================================
  //  Board ID 管理（URL 参数）
  // =============================================
  function getBoardId() {
    const params = new URLSearchParams(window.location.search);
    let boardId = params.get('board');
    if (!boardId) {
      boardId = 'board-' + Math.random().toString(36).slice(2, 10);
      const newUrl = window.location.pathname + '?board=' + boardId + window.location.hash;
      window.history.replaceState(null, '', newUrl);
    }
    return boardId;
  }

  const boardId = getBoardId();
  const boardRef = db.ref('boards/' + boardId);
  const strokesRef = boardRef.child('strokes');
  const cursorsRef = boardRef.child('cursors');
  const presenceRef = boardRef.child('presence');
  const clearRef = boardRef.child('clearSignal');
  const snapshotRef = boardRef.child('snapshot');
  const riddlesRef = boardRef.child('riddles');

  // 显示 Board ID
  const boardIdTag = document.getElementById('boardIdTag');
  boardIdTag.textContent = 'BOARD: ' + boardId.slice(0, 12);
  boardIdTag.title = '点击复制分享链接: ' + window.location.href;
  boardIdTag.addEventListener('click', () => {
    navigator.clipboard.writeText(window.location.href).then(() => {
      showToast('LINK COPIED!');
    }).catch(() => {
      showToast('COPY FAILED');
    });
  });

  // =============================================
  //  玩家 ID & 在线状态 (Firebase Presence)
  // =============================================
  const myPlayerId = 'P' + Math.random().toString(36).slice(2, 6).toUpperCase();
  const myPresenceRef = presenceRef.child(myPlayerId);

  // 设置 onDisconnect，断线时自动清除
  myPresenceRef.set({ online: true, joinedAt: firebase.database.ServerValue.TIMESTAMP });
  myPresenceRef.onDisconnect().remove();

  // 同时清除光标
  const myCursorRef = cursorsRef.child(myPlayerId);
  myCursorRef.onDisconnect().remove();

  // =============================================
  //  Game Boy 2-bit 调色板 (4色)
  // =============================================
  const GB_PALETTE = [
    { r: 15,  g: 56,  b: 15  },  // #0f380f - darkest
    { r: 48,  g: 98,  b: 48  },  // #306230 - dark
    { r: 139, g: 172, b: 15  },  // #8bac0f - light
    { r: 155, g: 188, b: 15  },  // #9bbc0f - lightest (background)
  ];
  const GB_BG_COLOR = '#9bbc0f';
  const GB_BG_RGB = GB_PALETTE[3];

  // =============================================
  //  基础设置
  // =============================================
  const drawCanvas = document.getElementById('drawCanvas');
  const drawCtx = drawCanvas.getContext('2d');
  const pixelCanvas = document.getElementById('pixelCanvas');
  const pixelCtx = pixelCanvas.getContext('2d');
  const canvasArea = document.getElementById('canvasArea');
  const toast = document.getElementById('toast');
  const eraserRing = document.getElementById('eraserRing');
  const coordsDisplay = document.getElementById('coordsDisplay');
  const canvasWrapper = document.querySelector('.canvas-wrapper');

  let currentColor = '#0f380f';
  let brushSize = 3;
  let tool = 'pen';
  let isDrawing = false;
  let lastX = 0, lastY = 0;
  let isPixelMode = false;

  // 标记：是否正在从 Firebase 加载数据（防止循环写入）
  let isLoadingFromFirebase = false;
  // 标记：是否已完成初始加载
  let initialLoadDone = false;

  // 历史记录
  const undoStack = [];
  const redoStack = [];
  const MAX_HISTORY = 40;

  function resizeCanvases() {
    const w = canvasArea.clientWidth;
    const h = canvasArea.clientHeight;
    if (w <= 0 || h <= 0) return;

    const imgData = (drawCanvas.width > 0 && drawCanvas.height > 0)
      ? drawCtx.getImageData(0, 0, drawCanvas.width, drawCanvas.height) : null;

    drawCanvas.width = w;
    drawCanvas.height = h;
    pixelCanvas.width = w;
    pixelCanvas.height = h;

    drawCtx.fillStyle = GB_BG_COLOR;
    drawCtx.fillRect(0, 0, w, h);

    if (imgData) drawCtx.putImageData(imgData, 0, 0);

    drawCtx.lineCap = 'round';
    drawCtx.lineJoin = 'round';
  }

  resizeCanvases();
  window.addEventListener('resize', resizeCanvases);
  if (typeof ResizeObserver !== 'undefined') {
    new ResizeObserver(() => resizeCanvases()).observe(canvasArea);
  }

  function initBackground() {
    drawCtx.fillStyle = GB_BG_COLOR;
    drawCtx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);
  }
  initBackground();

  // =============================================
  //  历史快照
  // =============================================
  function saveState() {
    undoStack.push(drawCtx.getImageData(0, 0, drawCanvas.width, drawCanvas.height));
    if (undoStack.length > MAX_HISTORY) undoStack.shift();
    redoStack.length = 0;
  }

  function undo() {
    if (undoStack.length === 0) return;
    redoStack.push(drawCtx.getImageData(0, 0, drawCanvas.width, drawCanvas.height));
    const state = undoStack.pop();
    drawCtx.putImageData(state, 0, 0);
    if (isPixelMode) pixelate();
    showToast('UNDO');
  }

  function redo() {
    if (redoStack.length === 0) return;
    undoStack.push(drawCtx.getImageData(0, 0, drawCanvas.width, drawCanvas.height));
    const state = redoStack.pop();
    drawCtx.putImageData(state, 0, 0);
    if (isPixelMode) pixelate();
    showToast('REDO');
  }

  // =============================================
  //  Toast 提示
  // =============================================
  let toastTimer = null;
  function showToast(msg) {
    toast.textContent = msg;
    toast.classList.add('show');
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => toast.classList.remove('show'), 1500);
  }

  // =============================================
  //  绘制逻辑
  // =============================================
  function getPointerPos(e, canvas) {
    const rect = canvas.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    return { x: clientX - rect.left, y: clientY - rect.top };
  }

  function startDraw(e) {
    e.preventDefault();
    if (tool === 'select') return; // 框选模式下不绘制
    isDrawing = true;
    const targetCanvas = isPixelMode ? pixelCanvas : drawCanvas;
    const pos = getPointerPos(e, targetCanvas);
    lastX = pos.x;
    lastY = pos.y;
    if (!isPixelMode) saveState();
  }

  function draw(e) {
    e.preventDefault();
    if (!isDrawing) return;

    const targetCanvas = isPixelMode ? pixelCanvas : drawCanvas;
    const ctx = isPixelMode ? pixelCtx : drawCtx;
    const pos = getPointerPos(e, targetCanvas);

    ctx.beginPath();
    ctx.moveTo(lastX, lastY);
    ctx.lineTo(pos.x, pos.y);

    let strokeColor, strokeSize;
    if (tool === 'eraser') {
      ctx.globalCompositeOperation = 'source-over';
      ctx.strokeStyle = GB_BG_COLOR;
      ctx.lineWidth = brushSize * 3;
      strokeColor = GB_BG_COLOR;
      strokeSize = brushSize * 3;
    } else {
      ctx.globalCompositeOperation = 'source-over';
      ctx.strokeStyle = currentColor;
      ctx.lineWidth = brushSize;
      strokeColor = currentColor;
      strokeSize = brushSize;
    }

    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.stroke();

    // 广播笔迹到 Firebase
    firebaseBroadcastStroke(lastX, lastY, pos.x, pos.y, strokeColor, strokeSize, tool === 'eraser');
    // 广播光标到 Firebase
    firebaseBroadcastCursor(pos.x, pos.y);

    lastX = pos.x;
    lastY = pos.y;
    coordsDisplay.textContent = `${Math.round(pos.x)},${Math.round(pos.y)}`;

    // 防抖自动保存
    clearTimeout(drawSaveTimer);
    drawSaveTimer = setTimeout(autoSaveToFirebase, 2000);
  }

  function endDraw(e) {
    if (e) e.preventDefault();
    if (isDrawing) {
      isDrawing = false;
      // 停笔后触发快照保存（防抖）
      clearTimeout(drawSaveTimer);
      drawSaveTimer = setTimeout(autoSaveToFirebase, 1000);
    }
  }

  let drawSaveTimer = null;

  // 事件绑定
  drawCanvas.addEventListener('mousedown', startDraw);
  drawCanvas.addEventListener('mousemove', draw);
  drawCanvas.addEventListener('mouseup', endDraw);
  drawCanvas.addEventListener('mouseleave', endDraw);
  drawCanvas.addEventListener('touchstart', startDraw, { passive: false });
  drawCanvas.addEventListener('touchmove', draw, { passive: false });
  drawCanvas.addEventListener('touchend', endDraw, { passive: false });
  drawCanvas.addEventListener('touchcancel', endDraw, { passive: false });

  pixelCanvas.addEventListener('mousedown', startDraw);
  pixelCanvas.addEventListener('mousemove', draw);
  pixelCanvas.addEventListener('mouseup', endDraw);
  pixelCanvas.addEventListener('mouseleave', endDraw);
  pixelCanvas.addEventListener('touchstart', startDraw, { passive: false });
  pixelCanvas.addEventListener('touchmove', draw, { passive: false });
  pixelCanvas.addEventListener('touchend', endDraw, { passive: false });
  pixelCanvas.addEventListener('touchcancel', endDraw, { passive: false });

  // =============================================
  //  橡皮擦视觉光标
  // =============================================
  document.addEventListener('mousemove', (e) => {
    if (tool === 'eraser') {
      const size = brushSize * 3;
      eraserRing.style.display = 'block';
      eraserRing.style.width = size + 'px';
      eraserRing.style.height = size + 'px';
      eraserRing.style.left = (e.clientX - size / 2) + 'px';
      eraserRing.style.top = (e.clientY - size / 2) + 'px';
    } else {
      eraserRing.style.display = 'none';
    }
  });

  // =============================================
  //  2-bit 像素化转换 (量化到 Game Boy 4色)
  // =============================================
  function nearestGBColor(r, g, b) {
    let minDist = Infinity;
    let best = 0;
    for (let i = 0; i < GB_PALETTE.length; i++) {
      const p = GB_PALETTE[i];
      const dr = r - p.r;
      const dg = g - p.g;
      const db = b - p.b;
      const dist = dr * dr + dg * dg + db * db;
      if (dist < minDist) {
        minDist = dist;
        best = i;
      }
    }
    return GB_PALETTE[best];
  }

  function pixelate() {
    const pixelSize = parseInt(document.getElementById('pixelSizeInput').value, 10) || 6;
    const w = drawCanvas.width;
    const h = drawCanvas.height;
    const srcData = drawCtx.getImageData(0, 0, w, h);
    const src = srcData.data;

    pixelCtx.fillStyle = GB_BG_COLOR;
    pixelCtx.fillRect(0, 0, w, h);

    for (let y = 0; y < h; y += pixelSize) {
      for (let x = 0; x < w; x += pixelSize) {
        let rSum = 0, gSum = 0, bSum = 0, count = 0;
        const bw = Math.min(pixelSize, w - x);
        const bh = Math.min(pixelSize, h - y);

        for (let by = 0; by < bh; by++) {
          for (let bx = 0; bx < bw; bx++) {
            const idx = ((y + by) * w + (x + bx)) * 4;
            rSum += src[idx];
            gSum += src[idx + 1];
            bSum += src[idx + 2];
            count++;
          }
        }

        const avgR = Math.round(rSum / count);
        const avgG = Math.round(gSum / count);
        const avgB = Math.round(bSum / count);

        const gbColor = nearestGBColor(avgR, avgG, avgB);
        pixelCtx.fillStyle = `rgb(${gbColor.r},${gbColor.g},${gbColor.b})`;

        const gap = pixelSize > 4 ? 1 : 0;
        pixelCtx.fillRect(x, y, pixelSize - gap, pixelSize - gap);
      }
    }
  }

  // 2色像素化（真正的二值化：前景 #0f380f + 背景 #9bbc0f）
  function pixelate2bit() {
    const pixelSize = parseInt(document.getElementById('pixelSizeInput').value, 10) || 6;
    const w = drawCanvas.width;
    const h = drawCanvas.height;
    const srcData = drawCtx.getImageData(0, 0, w, h);
    const src = srcData.data;

    const fg = GB_PALETTE[0]; // #0f380f
    const bg = GB_PALETTE[3]; // #9bbc0f
    const fgLum = 0.299 * fg.r + 0.587 * fg.g + 0.114 * fg.b;
    const bgLum = 0.299 * bg.r + 0.587 * bg.g + 0.114 * bg.b;
    const threshold = (fgLum + bgLum) / 2;

    pixelCtx.fillStyle = GB_BG_COLOR;
    pixelCtx.fillRect(0, 0, w, h);

    for (let y = 0; y < h; y += pixelSize) {
      for (let x = 0; x < w; x += pixelSize) {
        let lumSum = 0, count = 0;
        const bw = Math.min(pixelSize, w - x);
        const bh = Math.min(pixelSize, h - y);

        for (let by = 0; by < bh; by++) {
          for (let bx = 0; bx < bw; bx++) {
            const idx = ((y + by) * w + (x + bx)) * 4;
            lumSum += 0.299 * src[idx] + 0.587 * src[idx + 1] + 0.114 * src[idx + 2];
            count++;
          }
        }

        const avgLum = lumSum / count;
        const color = avgLum < threshold ? fg : bg;
        pixelCtx.fillStyle = `rgb(${color.r},${color.g},${color.b})`;

        const gap = pixelSize > 4 ? 1 : 0;
        pixelCtx.fillRect(x, y, pixelSize - gap, pixelSize - gap);
      }
    }
  }

  // =============================================
  //  工具栏事件
  // =============================================
  const btnPen = document.getElementById('btnPen');
  const btnEraser = document.getElementById('btnEraser');
  const btnPixelate = document.getElementById('btnPixelate');
  const btnPixelate2bit = document.getElementById('btnPixelate2bit');
  const btnOriginal = document.getElementById('btnOriginal');
  const btnUndo = document.getElementById('btnUndo');
  const btnRedo = document.getElementById('btnRedo');
  const btnClear = document.getElementById('btnClear');
  const btnSave = document.getElementById('btnSave');
  const btnSelect = document.getElementById('btnSelect');
  const sizeSlider = document.getElementById('sizeSlider');
  const sizeValue = document.getElementById('sizeValue');

  function switchTool(newTool) {
    tool = newTool;
    btnPen.classList.toggle('active', newTool === 'pen');
    btnEraser.classList.toggle('active', newTool === 'eraser');
    btnSelect.classList.toggle('active', newTool === 'select');
    if (newTool === 'eraser') {
      drawCanvas.classList.add('eraser-cursor');
      pixelCanvas.classList.add('eraser-cursor');
      drawCanvas.style.cursor = 'none';
      pixelCanvas.style.cursor = 'none';
    } else {
      drawCanvas.classList.remove('eraser-cursor');
      pixelCanvas.classList.remove('eraser-cursor');
      eraserRing.style.display = 'none';
      drawCanvas.style.cursor = newTool === 'select' ? 'crosshair' : 'crosshair';
      pixelCanvas.style.cursor = newTool === 'select' ? 'crosshair' : 'crosshair';
    }
  }

  btnPen.addEventListener('click', () => switchTool('pen'));
  btnEraser.addEventListener('click', () => switchTool('eraser'));
  btnSelect.addEventListener('click', () => switchTool('select'));

  document.querySelectorAll('.color-swatch').forEach(swatch => {
    swatch.addEventListener('click', () => {
      document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
      swatch.classList.add('active');
      currentColor = swatch.dataset.color;
    });
  });

  sizeSlider.addEventListener('input', (e) => {
    brushSize = parseInt(e.target.value, 10);
    sizeValue.textContent = brushSize;
  });

  btnPixelate.addEventListener('click', () => {
    pixelate();
    pixelCanvas.classList.add('visible');
    isPixelMode = true;
    btnPixelate.style.display = 'none';
    btnPixelate2bit.style.display = 'none';
    btnOriginal.style.display = '';
    showToast('4-COLOR PIXELIZED!');
  });

  btnPixelate2bit.addEventListener('click', () => {
    pixelate2bit();
    pixelCanvas.classList.add('visible');
    isPixelMode = true;
    btnPixelate.style.display = 'none';
    btnPixelate2bit.style.display = 'none';
    btnOriginal.style.display = '';
    showToast('2-COLOR PIXELIZED!');
  });

  btnOriginal.addEventListener('click', () => {
    pixelCanvas.classList.remove('visible');
    pixelCtx.clearRect(0, 0, pixelCanvas.width, pixelCanvas.height);
    isPixelMode = false;
    btnOriginal.style.display = 'none';
    btnPixelate.style.display = '';
    btnPixelate2bit.style.display = '';
    showToast('ORIGINAL');
  });

  btnUndo.addEventListener('click', undo);
  btnRedo.addEventListener('click', redo);

  document.addEventListener('keydown', (e) => {
    if (e.metaKey || e.ctrlKey) {
      if (e.key === 'z' && !e.shiftKey) { e.preventDefault(); undo(); }
      if (e.key === 'z' && e.shiftKey) { e.preventDefault(); redo(); }
      if (e.key === 'y') { e.preventDefault(); redo(); }
      if (e.key === 's') { e.preventDefault(); saveImage(); }
    }
  });

  // 清空
  btnClear.addEventListener('click', () => {
    saveState();
    drawCtx.fillStyle = GB_BG_COLOR;
    drawCtx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);
    pixelCtx.clearRect(0, 0, pixelCanvas.width, pixelCanvas.height);
    pixelCanvas.classList.remove('visible');
    isPixelMode = false;
    btnOriginal.style.display = 'none';
    btnPixelate.style.display = '';
    btnPixelate2bit.style.display = '';
    // 广播清空到 Firebase
    clearRef.set({ by: myPlayerId, at: firebase.database.ServerValue.TIMESTAMP });
    // 清空 Firebase 中的笔迹和快照
    strokesRef.remove();
    snapshotRef.remove();
    showToast('CLEARED');
  });

  // 保存
  btnSave.addEventListener('click', saveImage);

  function saveImage() {
    const exportCanvas = document.createElement('canvas');
    exportCanvas.width = drawCanvas.width;
    exportCanvas.height = drawCanvas.height;
    const exportCtx = exportCanvas.getContext('2d');

    if (isPixelMode) {
      exportCtx.drawImage(pixelCanvas, 0, 0);
    } else {
      exportCtx.drawImage(drawCanvas, 0, 0);
    }

    const link = document.createElement('a');
    link.download = 'pixel-notepad-' + boardId + '-' + Date.now() + '.png';
    link.href = exportCanvas.toDataURL('image/png');
    link.click();
    showToast('SAVED!');
  }

  // =============================================
  //  初始化
  // =============================================
  saveState();

  // =============================================
  //  导出 2-bit 像素画（不同尺寸）
  // =============================================
  const exportOverlay = document.getElementById('exportOverlay');
  const exportPreviewCanvas = document.getElementById('exportPreviewCanvas');
  const exportPreviewCtx = exportPreviewCanvas.getContext('2d');
  const exportPreviewInfo = document.getElementById('exportPreviewInfo');
  const exportPreviewWrap = document.getElementById('exportPreviewWrap');
  const btnExportPixel = document.getElementById('btnExportPixel');
  const exportCustomW = document.getElementById('exportCustomW');
  const exportCustomH = document.getElementById('exportCustomH');
  const exportCustomApply = document.getElementById('exportCustomApply');
  const exportDownload = document.getElementById('exportDownload');
  const exportClose = document.getElementById('exportClose');

  let exportW = 9, exportH = 9;

  // 真正的 2-bit = 只有 2 种颜色：前景（最深 #0f380f）+ 背景（最浅 #9bbc0f）
  const EXPORT_FG = GB_PALETTE[0]; // #0f380f
  const EXPORT_BG = GB_PALETTE[3]; // #9bbc0f

  function generatePixelExport(targetW, targetH) {
    // 1. 将画布内容缩小到 targetW x targetH
    const tmpCanvas = document.createElement('canvas');
    tmpCanvas.width = targetW;
    tmpCanvas.height = targetH;
    const tmpCtx = tmpCanvas.getContext('2d');
    tmpCtx.imageSmoothingEnabled = true;
    tmpCtx.imageSmoothingQuality = 'medium';

    // 取源画布（优先用像素模式的画布）
    const srcCanvas = isPixelMode ? pixelCanvas : drawCanvas;
    tmpCtx.drawImage(srcCanvas, 0, 0, srcCanvas.width, srcCanvas.height, 0, 0, targetW, targetH);

    // 2. 二值化：计算亮度，低于阈值为前景色，否则为背景色
    const imgData = tmpCtx.getImageData(0, 0, targetW, targetH);
    const px = imgData.data;

    // 背景色的亮度作为参考，阈值取前景与背景亮度的中点
    const fgLum = 0.299 * EXPORT_FG.r + 0.587 * EXPORT_FG.g + 0.114 * EXPORT_FG.b;
    const bgLum = 0.299 * EXPORT_BG.r + 0.587 * EXPORT_BG.g + 0.114 * EXPORT_BG.b;
    const threshold = (fgLum + bgLum) / 2;

    for (let i = 0; i < px.length; i += 4) {
      const lum = 0.299 * px[i] + 0.587 * px[i + 1] + 0.114 * px[i + 2];
      const color = lum < threshold ? EXPORT_FG : EXPORT_BG;
      px[i]     = color.r;
      px[i + 1] = color.g;
      px[i + 2] = color.b;
      px[i + 3] = 255;
    }
    tmpCtx.putImageData(imgData, 0, 0);
    return tmpCanvas;
  }

  function updateExportPreview() {
    const result = generatePixelExport(exportW, exportH);

    // 预览：放大显示，每个像素显示为方块
    const maxPreviewSize = 256;
    const scale = Math.max(1, Math.floor(maxPreviewSize / Math.max(exportW, exportH)));
    const previewW = exportW * scale;
    const previewH = exportH * scale;

    exportPreviewCanvas.width = previewW;
    exportPreviewCanvas.height = previewH;
    exportPreviewCtx.imageSmoothingEnabled = false;
    exportPreviewCtx.drawImage(result, 0, 0, exportW, exportH, 0, 0, previewW, previewH);

    exportPreviewCanvas.style.width = previewW + 'px';
    exportPreviewCanvas.style.height = previewH + 'px';

    exportPreviewInfo.textContent = exportW + 'x' + exportH;
  }

  function openExportPanel() {
    exportOverlay.classList.add('open');
    updateExportPreview();
  }

  function closeExportPanel() {
    exportOverlay.classList.remove('open');
  }

  btnExportPixel.addEventListener('click', openExportPanel);
  exportClose.addEventListener('click', closeExportPanel);
  exportOverlay.addEventListener('click', (e) => {
    if (e.target === exportOverlay) closeExportPanel();
  });

  // 尺寸按钮点击
  document.querySelectorAll('#exportSizes .export-size-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('#exportSizes .export-size-btn').forEach(b => b.classList.remove('selected'));
      btn.classList.add('selected');
      exportW = parseInt(btn.dataset.w, 10);
      exportH = parseInt(btn.dataset.h, 10);
      exportCustomW.value = exportW;
      exportCustomH.value = exportH;
      updateExportPreview();
    });
  });

  // 自定义尺寸
  exportCustomApply.addEventListener('click', () => {
    const w = Math.max(2, Math.min(512, parseInt(exportCustomW.value, 10) || 9));
    const h = Math.max(2, Math.min(512, parseInt(exportCustomH.value, 10) || 9));
    exportW = w;
    exportH = h;
    exportCustomW.value = w;
    exportCustomH.value = h;
    // 取消预设按钮的选中
    document.querySelectorAll('#exportSizes .export-size-btn').forEach(b => {
      const bw = parseInt(b.dataset.w, 10);
      const bh = parseInt(b.dataset.h, 10);
      b.classList.toggle('selected', bw === w && bh === h);
    });
    updateExportPreview();
  });

  // 下载
  exportDownload.addEventListener('click', () => {
    const result = generatePixelExport(exportW, exportH);
    const link = document.createElement('a');
    link.download = 'pixel-art-' + exportW + 'x' + exportH + '-' + boardId.slice(0, 8) + '.png';
    link.href = result.toDataURL('image/png');
    link.click();
    showToast(exportW + 'x' + exportH + ' EXPORTED!');
  });

  // =============================================
  //  自动保存到 Firebase (快照)
  // =============================================
  const autosaveIndicator = document.getElementById('autosaveIndicator');

  function autoSaveToFirebase() {
    if (isLoadingFromFirebase) return;
    try {
      const dataURL = drawCanvas.toDataURL('image/png');
      const saveData = {
        image: dataURL,
        timestamp: firebase.database.ServerValue.TIMESTAMP,
        isPixelMode,
        width: drawCanvas.width,
        height: drawCanvas.height,
      };
      if (isPixelMode) {
        saveData.pixelImage = pixelCanvas.toDataURL('image/png');
      }
      snapshotRef.set(saveData);
      // 同时保存到 localStorage 作为备份
      try {
        localStorage.setItem('pixel-notepad-autosave-' + boardId, JSON.stringify({
          image: dataURL,
          timestamp: Date.now(),
          isPixelMode,
        }));
      } catch (e) { /* localStorage 满了，忽略 */ }

      autosaveIndicator.classList.add('saving');
      setTimeout(() => autosaveIndicator.classList.remove('saving'), 800);
    } catch (e) {
      // 静默忽略
    }
  }

  // 定时自动保存（每 10 秒）
  setInterval(autoSaveToFirebase, 10000);

  // 页面关闭前保存
  window.addEventListener('beforeunload', () => {
    // 同步写入 localStorage（beforeunload 中异步请求可能被截断）
    try {
      const dataURL = drawCanvas.toDataURL('image/png');
      localStorage.setItem('pixel-notepad-autosave-' + boardId, JSON.stringify({
        image: dataURL,
        timestamp: Date.now(),
        isPixelMode,
      }));
    } catch (e) {}
  });

  // =============================================
  //  Firebase 实时广播：笔迹
  // =============================================
  // 用 push() 写入笔迹，每条笔迹自动获得唯一 key
  // 为避免数据无限增长，只保留最近的笔迹用于实时同步
  // 画布持久化靠 snapshot
  let strokeBatch = [];
  let strokeFlushTimer = null;

  function firebaseBroadcastStroke(fromX, fromY, toX, toY, color, size, isBgColor) {
    strokesRef.push({
      pid: myPlayerId,
      fx: Math.round(fromX * 10) / 10,
      fy: Math.round(fromY * 10) / 10,
      tx: Math.round(toX * 10) / 10,
      ty: Math.round(toY * 10) / 10,
      c: color,
      s: size,
      bg: isBgColor || false,
      pm: isPixelMode || false,
      cw: drawCanvas.width,
      ch: drawCanvas.height,
      t: firebase.database.ServerValue.TIMESTAMP,
    });
  }

  function firebaseBroadcastCursor(x, y) {
    myCursorRef.set({
      x: Math.round(x * 10) / 10,
      y: Math.round(y * 10) / 10,
      cw: drawCanvas.width,
      ch: drawCanvas.height,
      t: firebase.database.ServerValue.TIMESTAMP,
    });
  }

  // =============================================
  //  Firebase 实时监听：笔迹（child_added）
  // =============================================
  // 用时间戳过滤：只监听"此刻之后"新增的笔迹，避免重绘历史
  const listenSince = Date.now();

  strokesRef.orderByChild('t').startAt(listenSince).on('child_added', (snap) => {
    const s = snap.val();
    if (!s || s.pid === myPlayerId) return; // 忽略自己的笔迹

    const scaleX = drawCanvas.width / (s.cw || drawCanvas.width);
    const scaleY = drawCanvas.height / (s.ch || drawCanvas.height);
    const ctx = s.pm ? pixelCtx : drawCtx;

    ctx.beginPath();
    ctx.moveTo(s.fx * scaleX, s.fy * scaleY);
    ctx.lineTo(s.tx * scaleX, s.ty * scaleY);
    ctx.globalCompositeOperation = 'source-over';
    ctx.strokeStyle = s.c;
    ctx.lineWidth = s.s;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.stroke();

    // 自动清理旧笔迹（每条笔迹 10 秒后删除，节省数据库空间）
    setTimeout(() => { snap.ref.remove(); }, 10000);
  });

  // =============================================
  //  Firebase 实时监听：光标（value）
  // =============================================
  const remoteCursors = {};
  const onlineCountEl = document.getElementById('onlineCount');

  function getOrCreateRemoteCursor(playerId) {
    if (remoteCursors[playerId]) {
      return remoteCursors[playerId].el;
    }
    const el = document.createElement('div');
    el.className = 'remote-cursor';
    el.innerHTML = `<div class="remote-cursor-dot"></div><div class="remote-cursor-label">${playerId}</div>`;
    canvasWrapper.appendChild(el);
    remoteCursors[playerId] = { el };
    return el;
  }

  function removeRemoteCursor(playerId) {
    if (remoteCursors[playerId]) {
      remoteCursors[playerId].el.remove();
      delete remoteCursors[playerId];
    }
  }

  cursorsRef.on('value', (snap) => {
    const data = snap.val() || {};
    // 移除不存在的光标
    Object.keys(remoteCursors).forEach(pid => {
      if (!data[pid]) removeRemoteCursor(pid);
    });
    // 更新/创建光标
    Object.keys(data).forEach(pid => {
      if (pid === myPlayerId) return;
      const c = data[pid];
      if (!c) return;
      const scaleX = drawCanvas.width / (c.cw || drawCanvas.width);
      const scaleY = drawCanvas.height / (c.ch || drawCanvas.height);
      const el = getOrCreateRemoteCursor(pid);
      el.style.left = (c.x * scaleX) + 'px';
      el.style.top = (c.y * scaleY) + 'px';
    });
  });

  // =============================================
  //  Firebase 实时监听：在线人数（presence）
  // =============================================
  presenceRef.on('value', (snap) => {
    const data = snap.val() || {};
    const count = Object.keys(data).length;
    onlineCountEl.textContent = count + ' ONLINE';
  });

  // =============================================
  //  Firebase 实时监听：清空信号
  // =============================================
  clearRef.on('value', (snap) => {
    const data = snap.val();
    if (!data) return;
    // 只响应别人的清空
    if (data.by === myPlayerId) return;

    drawCtx.fillStyle = GB_BG_COLOR;
    drawCtx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);
    pixelCtx.clearRect(0, 0, pixelCanvas.width, pixelCanvas.height);
    if (isPixelMode) {
      pixelCanvas.classList.remove('visible');
      isPixelMode = false;
      btnOriginal.style.display = 'none';
      btnPixelate.style.display = '';
    }
    showToast('CLEARED BY ' + data.by);
  });

  // =============================================
  //  Firebase 加载画布快照（首次进入）
  // =============================================
  function loadSnapshotFromFirebase() {
    snapshotRef.once('value').then((snap) => {
      const data = snap.val();
      if (!data || !data.image) {
        // 没有快照，尝试从 localStorage 恢复
        loadFromLocalStorage();
        initialLoadDone = true;
        return;
      }

      isLoadingFromFirebase = true;
      const img = new Image();
      img.onload = () => {
        drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
        drawCtx.fillStyle = GB_BG_COLOR;
        drawCtx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);
        drawCtx.drawImage(img, 0, 0, data.width || drawCanvas.width, data.height || drawCanvas.height,
                          0, 0, drawCanvas.width, drawCanvas.height);
        saveState();

        if (data.isPixelMode && data.pixelImage) {
          const pImg = new Image();
          pImg.onload = () => {
            pixelCtx.clearRect(0, 0, pixelCanvas.width, pixelCanvas.height);
            pixelCtx.drawImage(pImg, 0, 0, data.width || pixelCanvas.width, data.height || pixelCanvas.height,
                               0, 0, pixelCanvas.width, pixelCanvas.height);
            pixelCanvas.classList.add('visible');
            isPixelMode = true;
            btnPixelate.style.display = 'none';
            btnOriginal.style.display = '';
          };
          pImg.src = data.pixelImage;
        }

        isLoadingFromFirebase = false;
        initialLoadDone = true;
        showToast('SYNCED!');
      };
      img.onerror = () => {
        isLoadingFromFirebase = false;
        initialLoadDone = true;
        loadFromLocalStorage();
      };
      img.src = data.image;
    }).catch(() => {
      initialLoadDone = true;
      loadFromLocalStorage();
    });
  }

  function loadFromLocalStorage() {
    try {
      const raw = localStorage.getItem('pixel-notepad-autosave-' + boardId);
      if (!raw) return;
      const saveData = JSON.parse(raw);
      if (!saveData.image) return;

      const img = new Image();
      img.onload = () => {
        drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
        drawCtx.fillStyle = GB_BG_COLOR;
        drawCtx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);
        drawCtx.drawImage(img, 0, 0);
        saveState();
        showToast('LOCAL RESTORE!');
      };
      img.src = saveData.image;
    } catch (e) { /* 忽略 */ }
  }

  // 启动加载
  loadSnapshotFromFirebase();

  // =============================================
  //  你画我猜 - 框选 & 谜题系统
  // =============================================
  const selectRect = document.getElementById('selectRect');
  const riddleSetOverlay = document.getElementById('riddleSetOverlay');
  const riddleSetInput = document.getElementById('riddleSetInput');
  const riddleSetConfirm = document.getElementById('riddleSetConfirm');
  const riddleSetCancel = document.getElementById('riddleSetCancel');
  const riddleGuessOverlay = document.getElementById('riddleGuessOverlay');
  const riddleGuessInput = document.getElementById('riddleGuessInput');
  const riddleGuessHint = document.getElementById('riddleGuessHint');
  const riddleGuessConfirm = document.getElementById('riddleGuessConfirm');
  const riddleGuessCancel = document.getElementById('riddleGuessCancel');
  const riddleSuccessOverlay = document.getElementById('riddleSuccessOverlay');
  const riddleSuccessWord = document.getElementById('riddleSuccessWord');
  const riddleSuccessClose = document.getElementById('riddleSuccessClose');

  // 框选状态
  let isSelecting = false;
  let selectStartX = 0, selectStartY = 0;
  let selectEndX = 0, selectEndY = 0;

  // 本地 riddle 标签元素 map（key = firebase key）
  const riddleTags = {};

  // 当前正在猜的 riddle key
  let currentGuessKey = null;

  // 获取 canvasArea 相对于 viewport 的位置
  function getCanvasAreaRect() {
    return canvasArea.getBoundingClientRect();
  }

  // ---- 框选事件（仅在 tool === 'select' 时激活）----
  function selectStart(e) {
    if (tool !== 'select') return;
    e.preventDefault();
    const targetCanvas = isPixelMode ? pixelCanvas : drawCanvas;
    const pos = getPointerPos(e, targetCanvas);
    isSelecting = true;
    selectStartX = pos.x;
    selectStartY = pos.y;
    selectEndX = pos.x;
    selectEndY = pos.y;
    updateSelectRectUI();
    selectRect.style.display = 'block';
  }

  function selectMove(e) {
    if (!isSelecting || tool !== 'select') return;
    e.preventDefault();
    const targetCanvas = isPixelMode ? pixelCanvas : drawCanvas;
    const pos = getPointerPos(e, targetCanvas);
    selectEndX = pos.x;
    selectEndY = pos.y;
    updateSelectRectUI();
  }

  function selectEnd(e) {
    if (!isSelecting || tool !== 'select') return;
    if (e) e.preventDefault();
    isSelecting = false;

    const x = Math.min(selectStartX, selectEndX);
    const y = Math.min(selectStartY, selectEndY);
    const w = Math.abs(selectEndX - selectStartX);
    const h = Math.abs(selectEndY - selectStartY);

    // 选区太小则忽略
    if (w < 10 || h < 10) {
      selectRect.style.display = 'none';
      return;
    }

    // 弹出设置谜题弹窗
    openRiddleSetPanel(x, y, w, h);
  }

  function updateSelectRectUI() {
    const areaRect = getCanvasAreaRect();
    const x = Math.min(selectStartX, selectEndX);
    const y = Math.min(selectStartY, selectEndY);
    const w = Math.abs(selectEndX - selectStartX);
    const h = Math.abs(selectEndY - selectStartY);
    selectRect.style.left = (areaRect.left + x) + 'px';
    selectRect.style.top = (areaRect.top + y) + 'px';
    selectRect.style.width = w + 'px';
    selectRect.style.height = h + 'px';
  }

  // 为两个画布都绑定框选事件
  [drawCanvas, pixelCanvas].forEach(cvs => {
    cvs.addEventListener('mousedown', selectStart);
    cvs.addEventListener('mousemove', selectMove);
    cvs.addEventListener('mouseup', selectEnd);
    cvs.addEventListener('touchstart', selectStart, { passive: false });
    cvs.addEventListener('touchmove', selectMove, { passive: false });
    cvs.addEventListener('touchend', selectEnd, { passive: false });
  });

  // ---- 设置谜题弹窗 ----
  let pendingRiddleRect = null;

  function openRiddleSetPanel(x, y, w, h) {
    pendingRiddleRect = {
      x: x / drawCanvas.width,
      y: y / drawCanvas.height,
      w: w / drawCanvas.width,
      h: h / drawCanvas.height,
    };
    riddleSetInput.value = '';
    riddleSetOverlay.classList.add('open');
    setTimeout(() => riddleSetInput.focus(), 100);
  }

  function closeRiddleSetPanel() {
    riddleSetOverlay.classList.remove('open');
    selectRect.style.display = 'none';
    pendingRiddleRect = null;
  }

  riddleSetCancel.addEventListener('click', closeRiddleSetPanel);
  riddleSetOverlay.addEventListener('click', (e) => {
    if (e.target === riddleSetOverlay) closeRiddleSetPanel();
  });

  riddleSetConfirm.addEventListener('click', submitRiddle);
  riddleSetInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') submitRiddle();
  });

  function submitRiddle() {
    const answer = riddleSetInput.value.trim();
    if (!answer) {
      riddleSetInput.style.borderColor = '#ff6060';
      setTimeout(() => riddleSetInput.style.borderColor = '', 800);
      return;
    }
    if (!pendingRiddleRect) return;

    // 存入 Firebase
    const newRef = riddlesRef.push();
    newRef.set({
      rx: pendingRiddleRect.x,
      ry: pendingRiddleRect.y,
      rw: pendingRiddleRect.w,
      rh: pendingRiddleRect.h,
      answer: answer,
      createdBy: myPlayerId,
      solvedBy: null,
      createdAt: firebase.database.ServerValue.TIMESTAMP,
    });

    closeRiddleSetPanel();
    switchTool('pen');
    showToast('RIDDLE SET!');
  }

  // ---- 在画布上创建/更新 riddle 标签 ----
  function createRiddleTag(key, data) {
    if (riddleTags[key]) {
      updateRiddleTagPosition(key, data);
      return;
    }

    const tag = document.createElement('div');
    tag.className = 'riddle-tag';
    tag.dataset.riddleKey = key;

    const label = document.createElement('span');
    label.className = 'riddle-tag-label';

    if (data.solvedBy) {
      label.textContent = '★ ' + data.answer + ' ★';
      tag.classList.add('solved');
      tag.title = data.solvedBy + ' 猜中了！';
    } else if (data.createdBy === myPlayerId) {
      label.textContent = '???（' + data.answer + '）';
      tag.title = '你出的题';
    } else {
      label.textContent = '???';
      tag.title = '点击猜猜看！';
    }

    tag.appendChild(label);

    tag.addEventListener('click', () => {
      if (data.solvedBy) return;
      if (data.createdBy === myPlayerId) return;
      openGuessPanel(key);
    });

    tag.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      showPixelConfirm('删除这个猜谜框？', () => {
        riddlesRef.child(key).remove();
        showToast('RIDDLE DELETED');
      });
    });

    canvasWrapper.appendChild(tag);
    riddleTags[key] = { el: tag, data };
    updateRiddleTagPosition(key, data);
  }

  function updateRiddleTagPosition(key, data) {
    const entry = riddleTags[key];
    if (!entry) return;
    const el = entry.el;
    const cw = drawCanvas.width;
    const ch = drawCanvas.height;
    el.style.left = (data.rx * cw) + 'px';
    el.style.top = (data.ry * ch) + 'px';
    el.style.width = (data.rw * cw) + 'px';
    el.style.height = (data.rh * ch) + 'px';
    entry.data = data;
  }

  function removeRiddleTag(key) {
    if (riddleTags[key]) {
      riddleTags[key].el.remove();
      delete riddleTags[key];
    }
  }

  // ---- 猜谜弹窗 ----
  function openGuessPanel(riddleKey) {
    currentGuessKey = riddleKey;
    riddleGuessInput.value = '';
    riddleGuessHint.style.display = 'none';
    riddleGuessOverlay.classList.add('open');
    setTimeout(() => riddleGuessInput.focus(), 100);
  }

  function closeGuessPanel() {
    riddleGuessOverlay.classList.remove('open');
    currentGuessKey = null;
  }

  riddleGuessCancel.addEventListener('click', closeGuessPanel);
  riddleGuessOverlay.addEventListener('click', (e) => {
    if (e.target === riddleGuessOverlay) closeGuessPanel();
  });

  riddleGuessConfirm.addEventListener('click', checkGuess);
  riddleGuessInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') checkGuess();
  });

  function checkGuess() {
    if (!currentGuessKey) return;
    const entry = riddleTags[currentGuessKey];
    if (!entry) return;

    const guess = riddleGuessInput.value.trim().toLowerCase();
    const answer = entry.data.answer.trim().toLowerCase();

    if (guess === answer) {
      // 猜中了！更新 Firebase
      riddlesRef.child(currentGuessKey).update({
        solvedBy: myPlayerId,
      });
      closeGuessPanel();
      showSuccessPanel(entry.data.answer);
    } else {
      // 猜错了
      riddleGuessHint.style.display = 'block';
      riddleGuessInput.value = '';
      riddleGuessInput.focus();
      setTimeout(() => { riddleGuessHint.style.display = 'none'; }, 2000);
    }
  }

  // ---- 猜中弹窗 ----
  function showSuccessPanel(word) {
    riddleSuccessWord.textContent = '「' + word + '」';
    riddleSuccessOverlay.classList.add('open');
  }

  riddleSuccessClose.addEventListener('click', () => {
    riddleSuccessOverlay.classList.remove('open');
  });
  riddleSuccessOverlay.addEventListener('click', (e) => {
    if (e.target === riddleSuccessOverlay) riddleSuccessOverlay.classList.remove('open');
  });

  // ---- Firebase 监听 riddles ----
  riddlesRef.on('child_added', (snap) => {
    const data = snap.val();
    if (!data) return;
    createRiddleTag(snap.key, data);
  });

  riddlesRef.on('child_changed', (snap) => {
    const data = snap.val();
    if (!data) return;
    // 更新标签（可能被猜中了）
    removeRiddleTag(snap.key);
    createRiddleTag(snap.key, data);
  });

  riddlesRef.on('child_removed', (snap) => {
    removeRiddleTag(snap.key);
  });

  // 窗口 resize 时更新 riddle 标签位置
  window.addEventListener('resize', () => {
    Object.keys(riddleTags).forEach(key => {
      const entry = riddleTags[key];
      if (entry) updateRiddleTagPosition(key, entry.data);
    });
  });

  // =============================================
  //  像素风确认弹窗（替代浏览器 confirm）
  // =============================================
  function showPixelConfirm(message, onConfirm) {
    const overlay = document.createElement('div');
    overlay.className = 'pixel-confirm-overlay';
    overlay.innerHTML = `
      <div class="pixel-confirm-panel">
        <div class="pixel-confirm-msg">${message}</div>
        <div class="pixel-confirm-btns">
          <button class="pixel-confirm-btn yes">✓ 确认</button>
          <button class="pixel-confirm-btn no">✕ 取消</button>
        </div>
      </div>
    `;
    document.body.appendChild(overlay);

    const yesBtn = overlay.querySelector('.pixel-confirm-btn.yes');
    const noBtn = overlay.querySelector('.pixel-confirm-btn.no');

    function close() {
      overlay.remove();
    }

    yesBtn.addEventListener('click', () => {
      close();
      if (onConfirm) onConfirm();
    });
    noBtn.addEventListener('click', close);
    overlay.addEventListener('click', (e) => {
      if (e.target === overlay) close();
    });
  }

</script>

</body>
</html>
